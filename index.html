<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Keryx Solutions - Your Partner in Technology</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="index.css" />
    <script src="https://unpkg.com/embla-carousel@8.0.0/embla-carousel.umd.js"></script>
  </head>

  <body>
    <!-- Header -->
    <header>
      <div class="container header-container">
        <a href="#" class="logo">Keryx Solutions</a>
        <nav>
          <ul>
            <li><a href="#our-work">Our Work</a></li>
            <li><a href="#services">Services</a></li>
            <li><a href="#about">About</a></li>
            <li><a href="#" class="cta-button open-modal">Get in touch</a></li>
          </ul>
        </nav>
      </div>
    </header>

    <!-- Hero Section -->
    <section class="hero">
      <div class="hero-content">
        <h1 class="headline-hero fade-in">Build what matters.</h1>
        <p class="body-large fade-in stagger-1">
          By focusing on your goals and providing you with the tools and
          insights you need, we build solutions that help you reach them with
          confidence.
        </p>
      </div>
    </section>

    <!-- Our Work Section -->
    <section id="our-work" class="work-gallery fade-in">
      <div class="container work-header">
        <h2 class="headline-large">Our Work.</h2>
        <p class="body-medium">
          Trusted by leading organizations to deliver solutions that drive results.
        </p>
      </div>
      <div class="embla work-slider">
        <div class="embla__viewport">
          <div class="embla__container work-track">
            <!-- Work items will be dynamically populated -->
          </div>
        </div>
      </div>
      <div class="work-paddle-nav">
        <ul>
          <li>
            <button
              id="work-left"
              aria-label="Previous item in work gallery"
              class="paddle-button"
            >
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36">
                <path
                  d="M20 25c-.384 0-.768-.146-1.06-.44l-5.5-5.5a1.5 1.5 0 0 1 0-2.12l5.5-5.5a1.5 1.5 0 1 1 2.12 2.12L16.622 18l4.44 4.44A1.5 1.5 0 0 1 20 25z"
                ></path>
              </svg>
            </button>
          </li>
          <li>
            <button
              id="work-right"
              aria-label="Next item in work gallery"
              class="paddle-button"
            >
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36">
                <path
                  d="M22.56 16.938l-5.508-5.5a1.493 1.493 0 0 0-2.116.003 1.502 1.502 0 0 0 .004 2.121L19.384 18l-4.444 4.438A1.502 1.502 0 0 0 15.996 25c.382 0 .764-.145 1.056-.438l5.508-5.5a1.502 1.502 0 0 0 0-2.125z"
                ></path>
              </svg>
            </button>
          </li>
        </ul>
      </div>
    </section>

    <!-- Services Cards Section -->
    <section id="services" class="tech-showcase">
      <div class="container">
        <h2 class="tech-header fade-in stagger-1">Get to know us.</h2>
      </div>
      <div class="tech-gallery">
        <div class="scroll-container">
          <div class="tech-grid">
            <div
              class="tech-card tech-card-with-bg"
              data-image="resources/card-solutions.png"
            >
              <h3 class="headline-medium text-shadow">Solutions Oriented</h3>
              <p class="text-shadow">
                Building the exact solution you need, without unnecessary
                complexity.
              </p>
            </div>
            <div
              class="tech-card tech-card-with-bg"
              data-image="resources/card-user-experience.png"
            >
              <h3 class="headline-medium text-shadow">
                User Experience Focused
              </h3>
              <p class="text-shadow">
                Designing elegant, human-centered interfaces that are effortless
                to use.
              </p>
            </div>
            <div
              class="tech-card tech-card-with-bg"
              data-image="resources/card-standards.png"
            >
              <h3 class="headline-medium text-shadow">Precision Engineered</h3>
              <p class="text-shadow">
                Applying modern development practices for reliable and
                maintainable code.
              </p>
            </div>
            <div
              class="tech-card tech-card-with-bg"
              data-image="resources/card-scalable.png"
            >
              <h3 class="headline-medium text-shadow">Future Proofed</h3>
              <p class="text-shadow">
                Designing future-proof systems that grow with your business
                needs.
              </p>
            </div>
            <div
              class="tech-card tech-card-with-bg"
              data-image="resources/card-ai.png"
            >
              <h3 class="headline-medium text-shadow">
                Intelligence Amplified
              </h3>
              <p class="text-shadow">
                Empowering you to navigate your most complex challenges through
                AI.
              </p>
            </div>
          </div>
        </div>
        <div class="paddle-nav">
          <ul>
            <li>
              <button
                id="scroll-left"
                aria-label="Previous item in services gallery"
                class="paddle-button"
                disabled
              >
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36">
                  <path
                    d="M20 25c-.384 0-.768-.146-1.06-.44l-5.5-5.5a1.5 1.5 0 0 1 0-2.12l5.5-5.5a1.5 1.5 0 1 1 2.12 2.12L16.622 18l4.44 4.44A1.5 1.5 0 0 1 20 25z"
                  ></path>
                </svg>
              </button>
            </li>
            <li>
              <button
                id="scroll-right"
                aria-label="Next item in services gallery"
                class="paddle-button"
              >
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36">
                  <path
                    d="M22.56 16.938l-5.508-5.5a1.493 1.493 0 0 0-2.116.003 1.502 1.502 0 0 0 .004 2.121L19.384 18l-4.444 4.438A1.502 1.502 0 0 0 15.996 25c.382 0 .764-.145 1.056-.438l5.508-5.5a1.502 1.502 0 0 0 0-2.125z"
                  ></path>
                </svg>
              </button>
            </li>
          </ul>
        </div>
      </div>
    </section>

    <!-- About Section -->
    <section id="about" class="about fade-in">
      <div class="about-hero">
        <div class="container">
          <div class="profile-image-container">
            <figure class="profile-image"></figure>
          </div>
          <div class="profile-headlines">
            <div class="profile-name">Bala Bosch</div>
            <div class="profile-title">Founder & Principal Engineer</div>
          </div>
        </div>
      </div>
      <div class="container">
        <div class="profile-content">
          <div class="about-content">
            <p class="bio-paragraph">
              Drawing on nearly three decades of software engineering
              experience, Bala brings deep expertise in AI and modern
              development practices to his role as principal engineer. His
              strategic mindset and technical skills enable him to identify
              opportunities for meaningful transformation in complex technical
              environments.
            </p>
            <p class="bio-paragraph">
              Throughout his career, Bala has demonstrated architectural
              excellence and team leadership in mission-critical environments.
              His deep understanding of systems architecture and AI integration
              reflects years of hands-on experience across evolving
              technological landscapes.
            </p>
            <p class="bio-paragraph">
              Certified in UX design by the Nielsen Norman Group, Bala brings a
              rare combination of technical depth and user empathy to his work.
              His appreciation for intuitive design stems from a belief that
              technology should enhance human capability rather than create new
              barriers.
            </p>
            <p class="bio-paragraph">
              As a technology enthusiast with a passion for innovation, Bala
              regularly contributes to the tech community through knowledge
              sharing and collaboration. His pragmatic approach to
              problem-solving comes from hands-on experience across diverse
              industries and technical environments.
            </p>
          </div>
        </div>
      </div>
    </section>

    <!-- Contact Section -->
    <section id="contact" class="value-prop">
      <div class="container">
        <div class="contact-content">
          <h2 class="headline-large fade-in">Take the next step.</h2>
          <p class="body-medium fade-in stagger-1">
            Connect with us today to build what matters for your business. We deliver
            reliable solutions that adapt to your evolving needs and create lasting
            value, whether for a single project or an ongoing partnership.
          </p>
          <span class="fade-in stagger-2"
            ><a href="#" class="cta-button open-modal">Get in touch</a></span
          >
        </div>
      </div>
    </section>

    <!-- Footer -->
    <footer>
      <div class="container">
        <div class="footer-content">
          <p>Copyright Â© 2025 Keryx Solutions, LLC. All rights reserved.</p>
        </div>
      </div>
    </footer>

    <!-- Modal -->
    <div id="appointment-modal" class="modal">
      <div class="modal-content">
        <span class="close-modal">&times;</span>
        <div class="modal-body">
          <!-- Google Calendar Appointment Scheduling begin -->
          <iframe
            src="https://calendar.google.com/calendar/appointments/schedules/AcZssZ0provwDCtwhRuWVBYv7zqlCAtBfIwdphMmIcWzKxAxITO9bumCJLOSNGH0M--MP_KLN8K9a6dv?gv=true"
            style="border: 0; vertical-align: bottom"
            width="100%"
            height="600"
            frameborder="0"
          ></iframe>
          <!-- end Google Calendar Appointment Scheduling -->
        </div>
      </div>
    </div>

    <script>
      // Intersection Observer for scroll animations
      const observerOptions = {
        threshold: 0.1,
        rootMargin: "0px 0px -100px 0px",
      };

      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            entry.target.classList.add("visible");
          }
        });
      }, observerOptions);

      // Observe all fade-in elements
      document.querySelectorAll(".fade-in").forEach((el) => {
        observer.observe(el);
      });

      // Smooth scroll for anchor links
      document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
        anchor.addEventListener("click", function (e) {
          e.preventDefault();
          const target = document.querySelector(this.getAttribute("href"));
          if (target) {
            const navHeight = document.querySelector("nav").offsetHeight;
            const targetPosition = target.offsetTop - navHeight;
            window.scrollTo({
              top: targetPosition,
              behavior: "smooth",
            });
          }
        });
      });

      // Shared carousel helper functions
      function setupCarousel(config) {
        const {
          scrollContainer,
          cardContainer,
          leftBtn,
          rightBtn,
          cardSelector,
          defaultScrollAmount = 392,
          infinite = false
        } = config;

        if (!scrollContainer || !cardContainer || !leftBtn || !rightBtn) {
          return;
        }

        let currentIndex = 0;
        let totalItems = 0;
        let duplicateCount = 0;
        let isTransitioning = false;

        // Get duplicate count and total items from the card container
        if (infinite && cardContainer.dataset.duplicateCount) {
          duplicateCount = parseInt(cardContainer.dataset.duplicateCount, 10);
          totalItems = parseInt(cardContainer.dataset.totalItems, 10);
          currentIndex = duplicateCount; // Start at the first real item
        }

        // Calculate scroll amount (one card width + gap)
        const calculateScrollAmount = () => {
          const cards = cardContainer.querySelectorAll(cardSelector);
          if (cards.length > 0) {
            const card = cards[0];
            const cardWidth = card.offsetWidth;
            const computedStyle = window.getComputedStyle(cardContainer);
            const gap =
              parseInt(computedStyle.getPropertyValue("gap"), 10) || 20;
            return cardWidth + gap;
          }
          return defaultScrollAmount;
        };

        // Update button states
        const updateButtonStates = () => {
          if (infinite) {
            // For infinite scroll, buttons are never disabled
            leftBtn.disabled = false;
            rightBtn.disabled = false;
          } else {
            const maxScroll =
              scrollContainer.scrollWidth - scrollContainer.clientWidth;
            leftBtn.disabled = scrollContainer.scrollLeft <= 0;
            rightBtn.disabled =
              scrollContainer.scrollLeft >= maxScroll - 2; // -2 for rounding errors
          }
        };

        // Get current index based on scroll position
        const getCurrentIndex = () => {
          const scrollAmount = calculateScrollAmount();
          return Math.round(scrollContainer.scrollLeft / scrollAmount);
        };

        // Scroll to specific index
        const scrollToIndex = (index, smooth = true) => {
          const scrollAmount = calculateScrollAmount();
          scrollContainer.scrollTo({
            left: index * scrollAmount,
            behavior: smooth ? "smooth" : "auto",
          });
          currentIndex = index;
        };

        // Handle infinite loop by repositioning to maintain buffer on both sides
        const handleInfiniteLoop = (targetIndex, fromManualScroll = false) => {
          if (!infinite || isTransitioning) return;

          // If we're at a duplicate at the start, jump to the real item at the end
          if (targetIndex < duplicateCount) {
            const realIndex = duplicateCount + totalItems + (targetIndex - duplicateCount);

            if (fromManualScroll) {
              // Instant jump for manual scroll
              scrollToIndex(realIndex, false);
              currentIndex = realIndex;
            } else {
              // Delayed jump for button clicks
              isTransitioning = true;
              setTimeout(() => {
                scrollToIndex(realIndex, false);
                currentIndex = realIndex;
                isTransitioning = false;
              }, 500);
            }
          }
          // If we're at a duplicate at the end, jump to the real item at the start
          else if (targetIndex >= duplicateCount + totalItems) {
            const realIndex = duplicateCount + (targetIndex - duplicateCount - totalItems);

            if (fromManualScroll) {
              // Instant jump for manual scroll
              scrollToIndex(realIndex, false);
              currentIndex = realIndex;
            } else {
              // Delayed jump for button clicks
              isTransitioning = true;
              setTimeout(() => {
                scrollToIndex(realIndex, false);
                currentIndex = realIndex;
                isTransitioning = false;
              }, 500);
            }
          }
        };

        // Scroll left
        leftBtn.addEventListener("click", () => {
          if (infinite && !isTransitioning) {
            currentIndex--;
            scrollToIndex(currentIndex);
            handleInfiniteLoop(currentIndex);
          } else if (!infinite) {
            const scrollAmount = calculateScrollAmount();
            scrollContainer.scrollBy({
              left: -scrollAmount,
              behavior: "smooth",
            });
          }
          setTimeout(updateButtonStates, 500);
        });

        // Scroll right
        rightBtn.addEventListener("click", () => {
          if (infinite && !isTransitioning) {
            currentIndex++;
            scrollToIndex(currentIndex);
            handleInfiniteLoop(currentIndex);
          } else if (!infinite) {
            const scrollAmount = calculateScrollAmount();
            scrollContainer.scrollBy({
              left: scrollAmount,
              behavior: "smooth",
            });
          }
          setTimeout(updateButtonStates, 500);
        });

        // Handle manual scroll (drag/swipe) for infinite loop
        let scrollTimeout;
        let lastScrollIndex = -1;
        let lastScrollLeft = 0;
        let scrollDirection = 0; // -1 = left, 1 = right, 0 = unknown

        // Check if a specific card is visible in viewport
        const isCardVisible = (cardIndex) => {
          const cards = cardContainer.querySelectorAll(cardSelector);
          if (!cards[cardIndex]) return false;

          const cardRect = cards[cardIndex].getBoundingClientRect();
          const containerRect = scrollContainer.getBoundingClientRect();

          // Card is visible if any part overlaps with container
          return cardRect.left < containerRect.right && cardRect.right > containerRect.left;
        };

        const handleManualScroll = () => {
          if (!infinite || isTransitioning) return;

          // Track scroll direction
          const currentScrollLeft = scrollContainer.scrollLeft;
          if (currentScrollLeft < lastScrollLeft) {
            scrollDirection = -1; // Scrolling left/backward
          } else if (currentScrollLeft > lastScrollLeft) {
            scrollDirection = 1; // Scrolling right/forward
          }
          lastScrollLeft = currentScrollLeft;

          const scrolledIndex = getCurrentIndex();

          // Prevent redundant repositioning
          if (lastScrollIndex === scrolledIndex) return;

          // Direction-based early repositioning when boundary items become visible
          // Only reposition if we're close to or in the duplicate zone to avoid premature jumps
          if (scrollDirection === -1 && scrolledIndex <= duplicateCount + 1 && isCardVisible(duplicateCount)) {
            // Scrolling backward, close to start, and first real item (index 3) is visible
            scrollToIndex(duplicateCount + totalItems, false);
            currentIndex = duplicateCount + totalItems;
            lastScrollIndex = duplicateCount + totalItems;
            return;
          } else if (scrollDirection === 1 && scrolledIndex >= duplicateCount + totalItems - 2 && isCardVisible(duplicateCount + totalItems - 1)) {
            // Scrolling forward, close to end, and last real item (index 20) is visible
            scrollToIndex(duplicateCount - 1, false);
            currentIndex = duplicateCount - 1;
            lastScrollIndex = duplicateCount - 1;
            return;
          }

          // Immediate handling for duplicate zones
          if (scrolledIndex < duplicateCount || scrolledIndex >= duplicateCount + totalItems) {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
              if (getCurrentIndex() === scrolledIndex) {
                currentIndex = scrolledIndex;
                handleInfiniteLoop(scrolledIndex, true);
                lastScrollIndex = scrolledIndex;
              }
            }, 200); // Small delay to let scroll snap settle
            return;
          }

          lastScrollIndex = scrolledIndex;
        };

        // Update button states on scroll and resize
        scrollContainer.addEventListener("scroll", () => {
          updateButtonStates();
          handleManualScroll();
        });

        window.addEventListener("resize", () => {
          updateButtonStates();
        });

        // Initial button state
        updateButtonStates();

        // For infinite scroll, position at the first real item (not the duplicates)
        if (infinite && duplicateCount > 0) {
          setTimeout(() => {
            scrollToIndex(duplicateCount, false);
          }, 0);
        }

        // Force a recalculation after a short delay to ensure proper initialization
        setTimeout(updateButtonStates, 100);
      }

      // Tech cards horizontal scroll functionality
      document.addEventListener("DOMContentLoaded", () => {
        const scrollContainer = document.querySelector(".scroll-container");
        const techGrid = document.querySelector(".tech-grid");
        const scrollLeftBtn = document.getElementById("scroll-left");
        const scrollRightBtn = document.getElementById("scroll-right");

        setupCarousel({
          scrollContainer,
          cardContainer: techGrid,
          leftBtn: scrollLeftBtn,
          rightBtn: scrollRightBtn,
          cardSelector: ".tech-card",
          defaultScrollAmount: 392
        });
      });

      // Add loading animation
      window.addEventListener("load", () => {
        document.body.style.opacity = "1";
      });

      // Render work gallery
      function renderWorkGallery(items) {
        const workTrack = document.querySelector(".work-track");
        if (!workTrack) return;

        const cardsHTML = items.map((item) => `
          <div class="embla__slide">
            <article class="work-card" aria-label="${item.project} for ${item.client}">
              <div class="work-picture">
                <img src="${item.image}" alt="${item.project}" width="340" height="190" />
              </div>
              <div class="work-copy">
                <h3 class="work-project">${item.project}</h3>
                <p class="work-client">${item.client}</p>
                <div class="work-details">
                  <p class="work-services">${item.services}</p>
                  <p class="work-stack">${item.stack}</p>
                </div>
              </div>
            </article>
          </div>
        `).join("");

        workTrack.innerHTML = cardsHTML;
      }

      // Load work items from JSON
      async function loadWorkItems() {
        try {
          const response = await fetch('resources/work-items.json');
          if (!response.ok) {
            throw new Error('Failed to load work items');
          }
          const items = await response.json();
          return items;
        } catch (error) {
          console.error('Error loading work items:', error);
          return [];
        }
      }

      // Initialize animations on load
      document.addEventListener("DOMContentLoaded", () => {
        // Trigger initial animations for elements in viewport
        const elementsInView = document.querySelectorAll(".fade-in");
        elementsInView.forEach((el) => {
          const rect = el.getBoundingClientRect();
          if (rect.top < window.innerHeight && rect.bottom > 0) {
            el.classList.add("visible");
          }
        });

        // Set background images from data-image attributes
        const cardsWithBg = document.querySelectorAll(".tech-card-with-bg");
        cardsWithBg.forEach((card) => {
          const imagePath = card.getAttribute("data-image");
          if (imagePath) {
            card.style.backgroundImage = `url('${imagePath}')`;
          }
        });

        // Render and setup work gallery
        loadWorkItems().then((items) => {
          if (items.length > 0) {
            renderWorkGallery(items);

            // Initialize Embla Carousel
            const emblaNode = document.querySelector(".work-slider .embla__viewport");
            const options = {
              loop: true,
              align: 'center',
              containScroll: 'trimSnaps',
              slidesToScroll: 1,
              skipSnaps: false
            };
            const emblaApi = EmblaCarousel(emblaNode, options);

            // Hook up navigation buttons
            const workLeftBtn = document.getElementById("work-left");
            const workRightBtn = document.getElementById("work-right");

            workLeftBtn.addEventListener("click", () => emblaApi.scrollPrev());
            workRightBtn.addEventListener("click", () => emblaApi.scrollNext());

            // Auto-show details for active slide (useful for touch devices)
            const updateActiveSlide = () => {
              const slides = emblaNode.querySelectorAll('.embla__slide');
              const selectedIndex = emblaApi.selectedScrollSnap();

              slides.forEach((slide, index) => {
                if (index === selectedIndex) {
                  slide.classList.add('embla__slide--active');
                } else {
                  slide.classList.remove('embla__slide--active');
                }
              });
            };

            emblaApi.on('select', updateActiveSlide);
            emblaApi.on('init', updateActiveSlide);
            updateActiveSlide(); // Initial call

            // Add horizontal wheel/touchpad scrolling support for continuous scrolling
            let scrollAccumulator = 0;
            let isScrolling = false;
            let scrollDirection = 0; // Track scroll direction

            emblaNode.addEventListener('wheel', (event) => {
              // Only handle horizontal scrolling (check if horizontal is dominant)
              if (Math.abs(event.deltaX) > Math.abs(event.deltaY)) {
                // Prevent default immediately to stop browser back/forward navigation
                event.preventDefault();

                // Track scroll direction
                scrollDirection = event.deltaX > 0 ? 1 : -1;

                // Accumulate scroll delta for smooth continuous scrolling
                scrollAccumulator += event.deltaX;

                if (!isScrolling) {
                  isScrolling = true;
                  requestAnimationFrame(function scrollStep() {
                    if (Math.abs(scrollAccumulator) > 0.5) {
                      // Calculate progress through the carousel
                      const scrollLength = emblaApi.scrollSnapList().length;
                      const currentProgress = emblaApi.scrollProgress();
                      const scrollDelta = scrollAccumulator / 2000; // Adjust sensitivity

                      // Calculate new target progress
                      let targetProgress = currentProgress + scrollDelta;

                      // For loop mode, allow wrapping
                      if (targetProgress < 0) targetProgress += 1;
                      if (targetProgress > 1) targetProgress -= 1;

                      // Convert progress to target index with directional snapping
                      const targetPosition = targetProgress * (scrollLength - 1);
                      let targetIndex;

                      // Snap in the direction of scroll to prevent backward jumps
                      if (scrollDirection > 0) {
                        // Scrolling forward: always round up (ceil)
                        targetIndex = Math.ceil(targetPosition);
                      } else {
                        // Scrolling backward: always round down (floor)
                        targetIndex = Math.floor(targetPosition);
                      }

                      // Scroll to target without animation for continuous feel
                      emblaApi.scrollTo(targetIndex, false);

                      // Decay the accumulator
                      scrollAccumulator *= 0.85;

                      requestAnimationFrame(scrollStep);
                    } else {
                      scrollAccumulator = 0;
                      isScrolling = false;
                    }
                  });
                }
              }
              // If vertical scroll dominates, do nothing (allow normal page scroll)
            }, { passive: false });
          }
        });
      });
      // Modal functionality
      const modal = document.getElementById("appointment-modal");
      const modalOpeners = document.querySelectorAll(".open-modal");
      const closeModal = document.querySelector(".close-modal");

      // Open modal when clicking any button with open-modal class
      modalOpeners.forEach((opener) => {
        opener.addEventListener("click", (e) => {
          e.preventDefault();
          modal.style.display = "block";
          document.body.classList.add("modal-open");
        });
      });

      // Close modal when clicking the close button
      closeModal.addEventListener("click", () => {
        modal.style.display = "none";
        document.body.classList.remove("modal-open");
      });

      // Close modal when clicking outside the modal content
      window.addEventListener("click", (e) => {
        if (e.target === modal) {
          modal.style.display = "none";
          document.body.classList.remove("modal-open");
        }
      });

      // Close modal with escape key
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && modal.style.display === "block") {
          modal.style.display = "none";
          document.body.classList.remove("modal-open");
        }
      });
    </script>
  </body>
</html>
